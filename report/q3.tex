\section{问题三的模型的建立和求解}
\subsection{问题三的描述与分析}

\subsection{预备工作}


\subsubsection{集合、索引与参数}

为适配附件三的多微基站、同频复用且存在小区间干扰的场景，定义如下集合与索引：

\begin{itemize}
  \item 基站集合：$\mathcal{N}=\{1,2,3\}$（分别对应 BS1、BS2、BS3）。
  \item 切片集合：$\mathcal{S}=\{U,e,m\}$，分别对应 URLLC、eMBB、mMTC。
  \item 用户集合：$\mathcal{K}=\mathcal{K}_U\cup\mathcal{K}_e\cup\mathcal{K}_m$，其中 $\mathcal{K}_U=\{\mathrm{U1},\mathrm{U2}\}$，$\mathcal{K}_e=\{\mathrm{e1},\dots,\mathrm{e12}\}$，$\mathcal{K}_m=\{\mathrm{m1},\dots,\mathrm{m30}\}$。
  \item 决策时刻集合：$\mathcal{T}=\{0,100,\dots,900\}$（单位 ms），每个决策窗口长度为 $100$ ms；窗口内以 $1$ ms 步长进行链路与队列仿真，记窗口内细粒度时刻集合为 $\mathcal{F}(t)=\{t,t+1,\dots,t+99\}$。
\end{itemize}

关键系统参数（与问题一、二保持一致）：

\begin{itemize}
  \item 每站可用 RB 总数 $R_{\text{tot}}=50$；单 RB 带宽 $b=360\,\mathrm{kHz}$；噪声系数 $NF=7\,\mathrm{dB}$；
  \item 切片占用粒度：$i_U=10,\ i_e=5,\ i_m=2$（每个并发用户占用的 RB 数）；
  \item 发射功率决策范围（第三问）：$p_{n,s}(t)\in[10,30]\,\mathrm{dBm}$，为“基站 $n$ 在窗口 $t$ 对切片 $s$ 的统一每 RB 功率”（切片内各 RB 功率一致）。
\end{itemize}

\subsection{模型建立}

\subsubsection{信道与干扰模型}

附件三提供了每 $1$ ms 的大规模损耗 $\phi_{n,k}(\tau)$（dB）与小规模瑞利衰落 $h_{n,k}(\tau)$。设窗口 $t\in\mathcal{T}$ 内细粒度时刻为 $\tau\in\mathcal{F}(t)$，若用户 $k\in\mathcal{K}_s$ 在窗口 $t$ 由基站 $n$ 服务且被分配切片 $s$ 的 RB，则其接收功率（mW）为
\begin{equation}
 p_{\mathrm{rx},n\to k}(\tau)=10^{\frac{p_{n,s}(t)-\phi_{n,k}(\tau)}{10}}\cdot |h_{n,k}(\tau)|^2.
\end{equation}

噪声功率与占用 RB 数 $i$ 成正比，换算为线性功率（mW）：
\begin{equation}
 N_0(i)=10^{\frac{-174+10\log_{10}(i\cdot b)+NF-30}{10}}.
\end{equation}

微基站同频复用引入同信道干扰。为保持“同一 RB 索引才互扰”的规则，我们令每站在窗口 $t$ 内将其 $50$ 个 RB 在频域上按切片连续划分且次序固定（例如 U-e-m），每个切片获得一段连续 RB 区间，跨站的相同 RB 索引构成同信道。于是用户 $k$ 的瞬时信干噪比为
\begin{equation}
 \gamma_k(\tau)=\frac{p_{\mathrm{rx},n\to k}(\tau)}{\sum\limits_{u\in\mathcal{N},\ u\neq n} I_{u\to k}(\tau)+N_0(i_s)},\quad s\in\mathcal{S},
\end{equation}
其中 $I_{u\to k}(\tau)$ 表示来自他站 $u$、在与 $k$ 所占 RB 索引重叠的切片 RB 上的干扰功率，按与上式相同的接收功率表达（由 $p_{u,s'}(t),\phi_{u,k}(\tau),h_{u,k}(\tau)$ 决定）。基于香农公式，窗口内瞬时速率为
\begin{equation}
 r_k(\tau)=i_s\cdot b\cdot \log_2\big(1+\gamma_k(\tau)\big)\quad(\mathrm{bps}).
\end{equation}
\subsubsection{任务到达与队列演化}

任务队列的动态演化过程与问题二完全一致，队列状态 $Q_k(t)$ 仍以每个用户为中心进行追踪，其演化遵循公式 \eqref{eq:queue_evolution}。

关键区别在于，服务量 $S_k(t)$ 的计算变得更为复杂，因为它取决于用户 $k$ 在当前窗口 $t$ 接入了哪个基站 $n$，以及所有基站的功率决策 $\{p_{n,s}(t)\}$。这将在后续的服务质量评估函数中具体体现。


\subsubsection{RB 切片并发与调度规则}

令 $x_{n,s}(t)$ 为窗口 $t$ 时基站 $n$ 切片 $s$ 的 RB 数，满足 $\sum_{s\in\mathcal{S}}x_{n,s}(t)=R_{\text{tot}}$。切片 $s$ 的并发容量为
\begin{equation}
 C_{n,s}(t)=\big\lfloor x_{n,s}(t)/i_s\big\rfloor.
\end{equation}
窗口内采用“编号靠前优先”的串-并行调度：每个 $(n,s)$ 最多同时服务 $C_{n,s}(t)$ 个队头任务，任务完成即释放并补位。URLLC 在切片内可按紧迫度（距 SLA 的剩余时限）优先。

\subsubsection{QoS 评估函数}

服务质量（QoS）的评估与前几问一致，核心是衡量每个任务的时延和速率是否满足服务等级协议（SLA）。

首先，我们需要计算每个任务的总时延。对于一个在时刻 $\tau$ 到达、数据量为 $D_{k,\tau}$ 的任务，其总时延 $L^{s}_{k,\tau}$ 由排队时延和传输时延两部分构成：
\begin{equation}
    L^{s}_{k,\tau} = \underbrace{(t_{\text{start}} - \tau)}_{\text{排队时延}} + \underbrace{\frac{D_{k,\tau} \cdot 10^6}{\bar{r}_k(t_{\text{start}})}}_{\text{传输时延}}
\end{equation}
其中，$t_{\text{start}}$ 是该任务开始被服务的时刻，$\bar{r}_k(t_{\text{start}})$ 是服务期间的平均数据速率。

然后，基于计算出的时延和瞬时速率，我们采用与前文相同的任务级 QoS 函数 $y^{s}_{k,\tau}$：
\begin{align}
 y^{U}_{k,\tau} &= \begin{cases}
 \alpha^{L^{U}_{k,\tau}} & L^{U}_{k,\tau}\le L^{\text{SLA}}_{U}\\
 -M_U & \text{否则}
 \end{cases} \\
y^{e}_{k,\tau} &= \begin{cases}
 1 & r_{k}(\tau_\text{srv})\ge r^{\text{SLA}}_{e}\ \text{and}\ L^{e}_{k,\tau}\le L^{\text{SLA}}_{e}\\
 \dfrac{r_{k}(\tau_\text{srv})}{r^{\text{SLA}}_{e}} & r_{k}(\tau_\text{srv})< r^{\text{SLA}}_{e}\ \text{and}\ L^{e}_{k,\tau}\le L^{\text{SLA}}_{e}\\
 -M_e & \text{否则}
 \end{cases} \\
 y^{m}_{k,\tau} &= \begin{cases}
 \dfrac{\sum\limits_{i\in\mathcal{K}_m}c'_i}{\sum\limits_{i\in\mathcal{K}_m}c_i} & L^{\,m}_{k,\tau}\le L^{\text{SLA}}_{m}\\
 -M_m & \text{否则}
 \end{cases}
\end{align}
参考取值：$\alpha=0.95$，$r^{\text{SLA}}_e=50\,\mathrm{Mbps}$，$L^{\text{SLA}}_{U}=5\,\mathrm{ms}$，$L^{\text{SLA}}_{e}=100\,\mathrm{ms}$，$L^{\text{SLA}}_{m}=500\,\mathrm{ms}$，$M_U=5, M_e=3, M_m=1$。

\subsubsection{决策变量与优化模型}

决策变量：
\begin{itemize}
  \item RB 切片分配：$x_{n,s}(t)\in\mathbb{Z}_{\ge 0}$
  \item 发射功率：$p_{n,s}(t)\in[10,30]\,\mathrm{(dBm)}$
  \item 接入关联：$a_{n,k}(t)\in\{0,1\}$,当 $a_{n,k}(t)=1$ 则 $k$ 在窗口 $t$ 仅由站 $n$ 调度
\end{itemize}

综合上述要素，第三问的动态联合优化模型可表述为（跨 10 个窗口聚合）：
\begin{equation}
\begin{aligned}
\max_{\{x,p,a\}}\quad & Q_{\text{total}}=\sum_{t\in\mathcal{T}}\Bigg[\sum_{k\in\mathcal{K}_U}\sum_{\tau\in\mathcal{A}_k(t)} y^{U}_{k,\tau}+\sum_{k\in\mathcal{K}_e}\sum_{\tau\in\mathcal{A}_k(t)} y^{e}_{k,\tau}+\sum_{k\in\mathcal{K}_m}\sum_{\tau\in\mathcal{A}_k(t)} y^{m}_{k,\tau}\Bigg] \\
\text{s.t.}\quad & 
\left\{
\begin{aligned}
&\sum_{s\in\mathcal{S}} x_{n,s}(t)=50 \\
&x_{n,U}(t)\bmod 10=0 ,x_{n,e}(t)\bmod 5=0 ,x_{n,m}(t)\bmod 2=0 \\
&x_{n,s}(t)\in\mathbb{Z}_{\ge 0} \\
&10\le p_{n,s}(t)\le 30\\
&Q_k(t+100)=\max\Big\{0,\ Q_k(t)+\sum_{\tau\in\mathcal{F}(t)} D_k(\tau)-S_k(t)\Big\} \\
&r_k(\tau),\ \gamma_k(\tau)\ \text{由}\ (x,p,a)\ \text{与}\ (\phi,h)\ \text{及调度生成} \\
&\sum_{n\in\mathcal{N}} a_{n,k}(t)\le 1 \\
&\forall n\in\mathcal{N},\ t\in\mathcal{T},\ \forall n,k,s,t
\end{aligned}
\right.
\end{aligned}
\end{equation}
其中 $\mathcal{A}_k(t)\subseteq\mathcal{F}(t)$ 为窗口 $t$ 内属于用户 $k$ 且在 SLA 内完成的任务到达时刻集合；$r_k(\tau)$ 与 $S_k(t)$ 均受干扰耦合与调度影响，是 $(x,p,a)$ 的非线性函数。\\
该模型体现了“多站同频干扰 + 切片化 RB 分配 + 切片级功率控制 + 任务队列”的耦合特性，属于带整数约束与非凸干扰项的时变 MINLP 问题。

\subsection{模型求解}

在前两问的“切片 RB 枚举 + 预测–控制 (MPC)”框架无法直接扩展到第三问的原因在于：
1) 决策维度急剧扩张，包含了 9 个连续的功率变量 $\{p_{n,s}\}$ 与 48 个离散的用户接入基站变量 $\{a_{n,k}\}$，构成了庞大的混合搜索空间。
2) 小区间干扰项使目标函数呈现强非凸、非线性特性，枚举或传统凸优化方法难以求解，计算量将呈指数级爆炸。

为兼顾求解质量与计算效率，本问采用“\textbf{滚动时窗预测控制(MPC)}+\textbf{混合编码遗传算法(GA)}”的两层求解范式。其总体求解流程如图~\ref{fig:flow_q3}所示。

\begin{figure}[htbp]
  \centering
  %\includesvg[width=0.95\textwidth]{q3_flowchart.svg}
  \caption{问题三“滚动 MPC + GA”求解流程图}
  \label{fig:flow_q3}
\end{figure}

\subsubsection{外层：滚动时窗预测控制 (MPC)}
我们将 1000 ms 的总时长离散为 10 个长度为 $T_w=100$ ms 的独立决策窗口。在每个窗口 $t$ 的开始，我们求解一个静态优化问题，以确定该窗口内恒定不变的资源分配策略（包括用户接入、RB切片、功率等级）。这种滚动优化的方式使得模型可以应对时变的信道和业务。

在我们的实现中，为降低问题的复杂度，我们做了一项简化：在每个窗口的优化求解阶段，我们假设该窗口开始时所有用户的任务队列均为空，即不考虑由前一个窗口积压下来的任务。优化过程仅针对当前窗口内新到达的任务负载。这使得每个窗口的优化问题可以解耦和独立求解。

\subsubsection{内层：混合编码遗传算法 (GA)}
针对每个窗口内的静态资源分配问题，我们设计了遗传算法进行启发式搜索。GA 能够有效处理高维、非凸、含混合变量的复杂优化问题。
\begin{itemize}
    \item \textbf{个体编码方案}：每个个体（染色体）代表一个完整的资源分配策略，采用混合编码，由三部分组成：
    \begin{enumerate}
        \item \textbf{用户接入决策}：长度为 48 的整数向量，每个基因位代表一个用户，其值（0, 1, 2）表示该用户接入的基站（BS1, BS2, BS3）。
        \item \textbf{RB 切片分配}：长度为 6 的整数向量，每两位表示一个基站为 URLLC 和 eMBB 切片分配的 RB 数量。mMTC 切片的比例则由剩余资源确定，并根据切片粒度约束进行解码。
        \item \textbf{切片功率控制}：长度为 9 的浮点数向量，每个基因位表示一个基站上特定切片（U/E/M）的发射功率（dBm），范围在 $[10, 30]$。
    \end{enumerate}
    \item \textbf{适应度函数}：个体的适应度由一个精细的仿真器评估。该仿真器将个体解码后的策略作为输入，以 1 ms 为步长模拟整个 100 ms 窗口的动态过程。仿真完整地计算了用户速率（包含所有基站的同频干扰）、任务队列的演化以及最终产生的 QoS 总分。该 QoS 总分即为个体的适应度。
    \item \textbf{遗传算子与参数}：
    GA 采用精英保留策略，并使用锦标赛选择、算术交叉（针对连续变量）/单点交叉（针对离散变量）和高斯/随机扰动变异（针对不同类型变量）来产生新一代种群。关键参数设置如下：种群大小为 40，最大进化代数为 200，精英个体保留 5 个，交叉概率 0.8，变异概率 0.3。
\end{itemize}

\subsubsection{求解流程}
算法的总体流程遵循“滚动时窗预测控制”框架，将1000ms的动态问题分解为10个独立的百毫秒优化窗口。在每个窗口的起点，我们利用遗传算法求解一个静态的资源分配优化问题。具体流程如下：

\textbf{Step 1：初始化}
在仿真开始前，通过 $`build_env`$函数一次性加载“附件三”中所有必需的数据，包括所有用户的任务到达流、各基站到各用户的大规模路径损耗和小规模瑞利衰落信道数据。

\textbf{Step 2：逐窗口迭代决策}
对于每个决策窗口 $w$（对应时间段 $[t, t+100)$，其中 $t = w \times 100$），执行以下内层优化：

\begin{enumerate}
    \item \textbf{GA种群初始化}：在窗口 $t$ 开始时，随机生成一个由 40 个个体组成的初始种群。每个个体（染色体）都代表了该窗口的一种完整资源分配方案，其编码包含了用户接入、RB切片和功率控制三部分决策。

    \item \textbf{适应度评估（窗口内仿真）}：对种群中的每一个个体，通过调用一个精细的仿真器$(`simulate_window_multibs`)$来评估其适应度（即QoS得分）。
    \begin{itemize}
        \item \textbf{空队列假设}：为使各窗口的优化问题解耦，仿真器在评估开始时，\textbf{假设所有用户的任务队列均为空}。它只考虑在当前$100ms$窗口内新到达的任务。
        \item \textbf{动态演化}：仿真器以1ms为步长，模拟100ms内的动态过程。在每个ms，它会处理新任务的到达，并根据个体所代表的资源分配方案（用户归属、RB和功率）以及全网的同频干扰，计算每个正在服务用户的瞬时速率，并更新其任务处理进度。
        \item \textbf{性能计算}：仿真器精确追踪每个任务从到达、排队到完成的完整生命周期，计算其端到端时延和平均速率，并依据QoS评估函数计算得分。所有在窗口内完成的任务的QoS得分总和，即为该个体的适应度。
    \end{itemize}

    \item \textbf{遗传进化}：采用精英保留策略，通过锦标赛选择、交叉和变异等遗传算子，从当前代种群生成下一代种群。此过程重复迭代 $200$ 代。

    \item \textbf{选择最优方案}：在$200$代进化完成后，选择整个过程中适应度最高的个体，将其解码为当前窗口 $w$ 的最终资源分配决策。
\end{enumerate}

\textbf{Step 3：汇总结果}
算法将每个窗口选出的最优方案及其对应的QoS得分、资源分配详情（RB、功率）和用户接入映射关系记录下来。重复Step 2直至完成所有10个决策窗口。最后，汇总所有窗口的记录，得到1000ms内的完整动态策略和累计总QoS。


\subsection{结果分析}

